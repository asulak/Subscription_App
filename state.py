from datetime import datetime, timedelta  # Importing datetime for date handling
from billing import calculate_proration_amount
from payment import create_stripe_payment_intent

"""
UserSessionState - Manages the state of a user session, including authentication status, current user details, and preferences.

This class is essential for tracking whether a user is logged in, which user is currently active, and what their current subscription is.
This information is stored temporarily in memory for the duration of the session and is not persisted to the database.
"""

class UserSessionState:
    def __init__(self):
        # Boolean flag to indicate if the user is logged in. Initialized to False since the user starts off unauthenticated.
        self.authenticated = False  
        
        # ID of the currently logged-in user. Initially set to None because no user is logged in when the session starts.
        self.user_id = None 
        
        # The user's active subscription, if any. This will typically hold a reference to a Subscription object.
        self.current_subscription = None   

    # Sets session to authenticated and stores user id and subscription
    def authenticate(self, user_id, subscription=None):
        self.authenticated = True
        self.user_id = user_id
        self.current_subscription = subscription

    # Resets session to initial state by clearing all stored information
    def logout(self):
        self.authenticated = False
        self.user_id = None
        self.current_subscription = None


"""
CartState - Manages a temporary selection of items (such as upgrades or add-ons) before a user commits to a purchase.

This class is useful in scenarios where users can add additional services or features to their subscription. 
Items added to the cart are tracked in-memory during the session and can be modified or cleared before finalizing the purchase.
"""

class CartState:
    def __init__(self):
        # A list to store items added to the cart. Each item is typically a dictionary containing item details (e.g., id, name, price).
        self.items = []
        
        # The total price of all items in the cart. This is a floating-point number representing the sum of the prices.
        self.total_price = 0.0
    
    # Adds item to cart and updates the total price
    def add_item(self, item):
        self.items.append(item)
        self.total_price += item['price']
    
    # Removes an item from the cart by its ID and updates the total price  
    def remove_item(self, item_id):
        item = next((i for i in self.items if i['id'] == item_id), None)
        if item:
            self.items.remove(item)
            self.total_price -= item['price']
            
    # Clears all items from cart and resets total price 
    def clear_cart(self):
        self.items = []
        self.total_price = 0.0


"""
SubscriptionUpgradeState - Manages the process of a user upgrading or downgrading their subscription.

This class temporarily holds information about the user's current plan, the new plan they want to switch to, 
and any necessary proration calculations (adjustments for switching plans mid-cycle).
"""

class SubscriptionUpgradeState:
    def __init__(self, current_plan):
        # The user's current subscription plan. This is typically an object or identifier representing the plan.
        self.current_plan = current_plan
        
        # The plan the user wants to switch to. Initially set to None until the user selects a new plan.
        self.new_plan = None  
        
        # The calculated prorated amount, which adjusts the cost based on how much of the current billing cycle has elapsed.
        self.prorated_amount = 0.0   
    
    # Updates the new plan and recalculates the proration
    def select_new_plan(self, new_plan):
        self.new_plan = new_plan
        self.calculate_proration()
        
        
    # Calculates the prorated amount when switching plans mid-cycle 
    def calculate_proration(self):
        self.prorated_amount = calculate_proration_amount(self.current_plan, self.new_plan)


"""
PaymentProcessingState - Manages the state during a payment process.

This class tracks the status of a payment transaction, including payment initiation, confirmation, and error handling.
It is useful for ensuring the payment process is completed correctly and for handling any errors that may occur.
"""

class PaymentProcessingState:
    def __init__(self):
        # The unique identifier for the payment intent, which is often generated by the payment processor (e.g., Stripe).
        self.payment_intent_id = None
        
        # The current status of the payment. Initially set to 'pending' since the payment process has just started.
        self.status = 'pending'
        
        # The amount of money involved in the payment, represented as a floating-point number.
        self.amount = 0.0
        
    # Initiates payment process by setting the amount and creating a payment intent 
    def start_payment(self, amount):
        self.amount = amount
        self.payment_intent_id = create_stripe_payment_intent(amount)
        self.status = 'pending'
        
    # Confirms the payment once the payment processor has successfully processed the transaction 
    def confirm_payment(self):
        self.status = 'confirmed'
        
    # Handles a payment failure by updating the status and storing the error message 
    def fail_payment(self, error):
        self.status = 'failed'
        self.error_message = error


"""
NotificationState - Manages notifications within the user session.

This class is responsible for tracking notifications sent to the user during the session, 
such as billing reminders, upgrade recommendations, or system alerts. It keeps track of which notifications have been read.
"""

class NotificationState:
    def __init__(self):
        # A list to store notifications. Each notification is typically a dictionary containing details such as message, level, and read status.
        self.notifications = []
        
        # An integer to track the number of unread notifications.
        self.unread_count = 0
        
    # Adds a new notification to the list and increments the unread count 
    def add_notification(self, message, level='info'):
        self.notifications.append({
            'message': message,
            'level': level,
            'read': False
        })
        self.unread_count += 1
        
    # Marks a specific notification as read and decrements the unread count if it was previously unread 
    def mark_as_read(self, index):
        if 0 <= index < len(self.notifications):
            if not self.notifications[index]['read']:
                self.notifications[index]['read'] = True
                self.unread_count -= 1
                
    # Retrieves a list of all unread notifications 
    def get_unread_notifications(self):
        return [n for n in self.notifications if not n['read']]


"""
TrialManagementState - Manages the state of a user's trial period.

This class tracks the start and end dates of a user's trial period and whether the trial has been converted to a paid subscription.
It is useful for ensuring that trials are handled correctly and for determining whether a user is still within their trial period.
"""

class TrialManagementState:
    def __init__(self, start_date, duration_days):
        # The date and time when the trial period starts.
        self.start_date = start_date
        
        # The date and time when the trial period ends. Calculated by adding the duration to the start date.
        self.end_date = start_date + timedelta(days=duration_days)
        
        # A boolean flag indicating whether the trial has been converted to a paid subscription.
        self.converted_to_paid = False

    # Marks the trial as converted to a paid subscription 
    def convert_to_paid(self):
        self.converted_to_paid = True

    # Checks whether the trial period is still active and has not yet been converted to a paid subscription 
    def is_trial_active(self):
        return datetime.utcnow() < self.end_date and not self.converted_to_paid

# AdminBillingState - manages the state of billing operations during an admin session.
class AdminBillingState:
    def __init__(self):
        self.invoice_list = []  # List of invoices currently being managed
        self.selected_invoice = None  # The invoice currently being managed

    def load_invoices(self, invoices):
        """Load a list of invoices into the state for management."""
        self.invoice_list = invoices

    def select_invoice(self, invoice_id):
        """Select an invoice to manage based on its ID."""
        self.selected_invoice = next((i for i in self.invoice_list if i.invoice_id == invoice_id), None)

    def add_invoice(self, invoice):
        """Add a new invoice to the list and select it for management."""
        self.invoice_list.append(invoice)
        self.selected_invoice = invoice

    def post_invoice(self):
        """Post the selected invoice, changing its status to 'posted'."""
        if self.selected_invoice:
            if self.selected_invoice.post():
                self.selected_invoice.status = 'posted'

    def delete_invoice(self, invoice_id):
        """Delete an invoice from the list based on its ID."""
        self.invoice_list = [i for i in self.invoice_list if i.invoice_id != invoice_id]
        if self.selected_invoice and self.selected_invoice.invoice_id == invoice_id:
            self.selected_invoice = None


# SubscriptionUpgradeState - manages the process of a user upgrading or downgrading their subscription.
class SubscriptionUpgradeState:
    def __init__(self, current_plan):
        self.current_plan = current_plan  # Current subscription plan the user is on
        self.new_plan = None  # The new subscription plan the user wants to switch to
        self.prorated_amount = 0.0  # The calculated prorated amount if the user switches mid-cycle

    def select_new_plan(self, new_plan):
        """Set the new plan and calculate proration."""
        self.new_plan = new_plan
        self.calculate_proration()
        
    def calculate_proration(self):
        """Calculate the prorated amount for the subscription change."""
        days_used = (datetime.utcnow() - self.current_plan.start_date).days
        self.prorated_amount = calculate_proration_amount(self.current_plan, self.new_plan, days_used)

    def apply_upgrade(self, user_subscription):
        """Apply the upgrade to the user's subscription in the state and prepare for database update."""
        user_subscription.plan_id = self.new_plan.id
        user_subscription.start_date = datetime.utcnow()
        user_subscription.end_date = datetime.utcnow() + timedelta(days=self.new_plan.duration_days)
        return self.prorated_amount, f'Successfully upgraded to {self.new_plan.name} with a prorated charge of {self.prorated_amount:.2f}'